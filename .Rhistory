vapply(data[-c(1,2), ], match_ratios, numeric(1),
p99 = data$p99,
p995 = data$p995,
p999 = data$p999,
p9999 = data$p9999,
type = t)
data[-c(1,2),]
match_ratios_data_wrapper <- function(data, type){
match_ratios(data$p99, data$p995, data$p999, data$p9999, type)
}
match_ratios_data_wrapper(data[5,], type="quadratic")
match_ratios_data_wrapper(data[6,], type="quadratic")
vapply(data[5:7], match_ratios_data_wrapper, numeric(1), type="quadratic")
vapply(data[5:7,], match_ratios_data_wrapper, numeric(1), type="quadratic")
sapply(data[5:7,], match_ratios_data_wrapper, type="quadratic")
vapply(data[5:7,], match_ratios_data_wrapper, numeric(1), type="quadratic")
ls.str()
data
data$p99
data[5:7,]
data[[1]]
split(data, rownames(data))
split(data, rownames(data))[[1]]
data_list <- split(data, rownames(data))[[1]]
data_list <- split(data, rownames(data))
data_list
vapply(data_list, match_ratios_data_wrapper, numeric(1), type="quadratic")
lapply(data_list, match_ratios_data_wrapper, type="quadratic")
data_list[3:5]
lapply(data_list[3:5], match_ratios_data_wrapper, type="quadratic")
x <- lapply(data_list[3:5], match_ratios_data_wrapper, type="quadratic")
x
x[1]
x[[1]]
x[[1]]$par
match_ratios_data_wrapper <- function(data, type){
match_ratios(data$p99, data$p995, data$p999, data$p9999, type)$par
}
rm(x)
lapply(data_list[3:5], match_ratios_data_wrapper, type="quadratic")
mapply(match_ratios_data_wrapper, data_list[3:5], c("quadratic", "absolute", "relative"))
mapply(match_ratios_data_wrapper, data = data_list[3:5],  type = c("quadratic", "absolute", "relative"))
match_ratios_data_wrapper <- function(data, type){
match_ratios(data$p99, data$p995, data$p999, data$p9999, type)$par
}
match_ratios <- function(p99, p995, p999, p9999,
type=c("quadratic", "absolute", "relative")){
if(is.na(p99)){
warning("99% quantile is missing")
return(NA)}
if(is.na(p995)){
stop("99.5% quantile is missing")
return(NA)}
if(is.na(p999)){warning("99.9% quantile is missing")}
if(is.na(p9999)){warning("99.99% quantile is missing")}
if(!is.vector(p99)){stop("99% quantile is not a correct format")}
if(!is.vector(p995)){stop("99.5% quantile is not a correct format")}
if(!is.vector(p999)){stop("99.9% quantile is not a correct format")}
if(!is.vector(p9999)){stop("99.99% quantile is not a correct format")}
if(!is.numeric(p99)){stop("99% quantile is not numeric")}
if(!is.numeric(p995)){stop("99.5% quantile is not numeric")}
if(!is.numeric(p999) & !is.na(p999)){stop("99.9% quantile is not numeric")}
if(!is.numeric(p9999) & !is.na(p9999)){stop("99.99½ quantle is not numeric")}
if(length(p99)>1){
warning("More then one 99% quantile, using first value")
p99 <- p99[1]
}
if(length(p995)>1){
warning("More then one 99.5% quantile, using first value")
p995 <- p995[1]
}
if(length(p999)>1){
warning("More then one 99.9% quantile, using first value")
p999 <- p999[1]
}
if(length(p9999)>1){
warning("More then one 99.99% quantile, using first value")
p9999 <- p9999[1]
}
require(minqa)
type <- match.arg(type)
shape_start_value <- get_shape_ratio995(p99 / p995)
bobyqa(shape_start_value, estimate_shape,
p99 = p99, p995 = p995, p999 = p999, p9999 = p9999, type = type)
}
match_ratios <- function(p99, p995, p999, p9999,
type=c("quadratic", "absolute", "relative")){
if(is.na(p99)){
warning("99% quantile is missing")
return(NA)}
if(is.na(p995)){
stop("99.5% quantile is missing")
return(NA)}
if(is.na(p999)){warning("99.9% quantile is missing")}
if(is.na(p9999)){warning("99.99% quantile is missing")}
if(!is.vector(p99)){stop("99% quantile is not a correct format")}
if(!is.vector(p995)){stop("99.5% quantile is not a correct format")}
if(!is.vector(p999)){stop("99.9% quantile is not a correct format")}
if(!is.vector(p9999)){stop("99.99% quantile is not a correct format")}
if(!is.numeric(p99)){stop("99% quantile is not numeric")}
if(!is.numeric(p995)){stop("99.5% quantile is not numeric")}
if(!is.numeric(p999) & !is.na(p999)){stop("99.9% quantile is not numeric")}
if(!is.numeric(p9999) & !is.na(p9999)){stop("99.99½ quantle is not numeric")}
if(length(p99)>1){
warning("More then one 99% quantile, using first value")
p99 <- p99[1]
}
if(length(p995)>1){
warning("More then one 99.5% quantile, using first value")
p995 <- p995[1]
}
if(length(p999)>1){
warning("More then one 99.9% quantile, using first value")
p999 <- p999[1]
}
if(length(p9999)>1){
warning("More then one 99.99% quantile, using first value")
p9999 <- p9999[1]
}
require(minqa)
type <- match.arg(type)
shape_start_value <- get_shape_ratio995(p99 / p995)
bobyqa(shape_start_value, estimate_shape,
p99 = p99, p995 = p995, p999 = p999, p9999 = p9999, type = type)
}
match_ratios(p_vec[1], p_vec[2], p_vec[3], p_vec[4], type = "quadratic")
p_vec <- c(1e+06, 2e+06, 1e+07, 1e+08)
match_ratios(p_vec[1], p_vec[2], p_vec[3], p_vec[4], type = "quadratic")
match_ratios(p_vec[1], p_vec[2], p_vec[3], p_vec[4], type = "absolute")
match_ratios(p_vec[1], p_vec[2], p_vec[3], p_vec[4], type = "relative")
match_ratios(NA, NA, p_vec[3], p_vec[4])
match_ratios(NA, p_vec[2], NA, p_vec[4])
match_ratios(NA, p_vec[2], p_vec[3], NA)
match_ratios(p_vec[1], NA, NA, p_vec[4])
match_ratios(p_vec[1], p_vec[2], NA, NA)
match_ratios_data_wrapper <- function(data, type){
tryCatch(
{match_ratios(data$p99, data$p995, data$p999, data$p9999, type)$par},
finally = NA
)
}
lapply(data_list[1:5], match_ratios_data_wrapper, type="quadratic")
lapply(data_list, match_ratios_data_wrapper, type="quadratic")
head(data_list)
match_ratios_data_wrapper <- function(data, type){
tryCatch(
{match_ratios(data$p99, data$p995, data$p999, data$p9999, type)$par},
error = function(){
warning("error")
return(NA)
}
)
}
lapply(data_list, match_ratios_data_wrapper, type="quadratic")
match_ratios_data_wrapper <- function(data, type){
tryCatch(
{match_ratios(data$p99, data$p995, data$p999, data$p9999, type)$par},
error = function(){
warning("error")
return(NA)
}
)
}
data[1,]
match_ratios_data_wrapper(data[1,], "quadratic")
match_ratios_data_wrapper <- function(data, type){
tryCatch(
{match_ratios(data$p99, data$p995, data$p999, data$p9999, type)$par},
error = function(){
message("error")
return(NA)
}
)
}
match_ratios_data_wrapper(data[1,], "quadratic")
match_ratios_data_wrapper <- function(data, type){
tryCatch(
{match_ratios(data$p99, data$p995, data$p999, data$p9999, type)$par},
error = function(cond){
message(cond)
return(NA)
}
)
}
match_ratios_data_wrapper(data[1,], "quadratic")
str(match_ratios_data_wrapper(data[1,], "quadratic"))
x <- (match_ratios_data_wrapper(data[1,], "quadratic")
)
x
lapply(data_list, match_ratios_data_wrapper, type= "quadratic")
x <- match_ratios_sequentiel <- function(data, type = c("quadratic", "absolute", "relative")){
sadf
adf
}
x <- lapply(data_list, match_ratios_data_wrapper, type= "quadratic")
x
x <- split(data), rownames(data))
x <- split(data, rownames(data))
x[[1]]
data[1,]
x <- as.list(as.data.frame(t(data)))
x[1]
x[[1]]
data[1,]
head(x)
head(data)
match_ratios_sequentiel <- function(data, type = c("quadratic", "absolute", "relative")){
type <- match.arg(type, several.ok = TRUE)
data_list <- as.list(as.data.frame(t(data)))
for(t in type){
data[, paste0(t, "Approximation")] <- unlist(lapply(
data_list,
match_ratios_data_wrapper,
type= t))
}
data
}
match_ratios_sequentiel(data)
data_list <- as.list(as.data.frame(t(data)))
data_list
data_list[1:3]
lapply(data_list[1:3], match_ratios_data_wrapper, type="quadratic")
data_list[[1]]
data_list[[1]]$p99
str(data_list[[1]])
str(data_list[[3]])
data_list[[3]]
data_list[[3]]["p99"]
data_list[[3]]["p99"]+1
data_list <- as.list(as.data.frame(t(data), drop = F]))
data_list <- as.list(as.data.frame(t(data), drop = F))
data_list[[1]]
data_list[[2]]
data_list <- as.list(as.data.frame(t(data)), drop = FALSE)
data_list[[2]]
data_list <- as.list(as.data.frame(t(data), stringsAsFactors = FALSE))
data_list[[2]]
data_list[[5]]
library(parallel)
head(data)
data[3:20,]
data <- data[3:20,]
dta
data
mapply(match_ratios, p99 = data$p99, p995 = data$p995, p999 = data$p999,
p9999 = data$p9999, type="quadratic" )
match_ratios_wrapper <- function(p99, p995, p999, p9999, type){
tryCatch(
{match_ratios(p99, p995, p999, p9999, type)$par},
error = function(e){
return(NA)
})
}
mapply(match_ratios_data_wrapper, p99 = data$p99, p995 = data$p995, p999 = data$p999,
p9999 = data$p9999, type="quadratic" )
match_ratios_wrapper <- function(p99, p995, p999, p9999, type){
match_ratios(p99, p995, p999, p9999, type)$par
}
mapply(match_ratios_data_wrapper, p99 = data$p99, p995 = data$p995, p999 = data$p999,
p9999 = data$p9999, type="quadratic" )
mapply(match_ratios_data, p99 = data$p99, p995 = data$p995, p999 = data$p999,
p9999 = data$p9999, type="quadratic" )
mapply(match_ratios_wrapper, p99 = data$p99, p995 = data$p995, p999 = data$p999,
p9999 = data$p9999, type="quadratic" )
rm(match_ratios_data_wrapper)
match_ratios_wrapper <- function(p99, p995, p999, p9999, type){
tryCatch(
{match_ratios(p99, p995, p999, p9999, type)$par},
error = function(e){
return(NA)
})
}
mapply(match_ratios_wrapper, p99 = data$p99, p995 = data$p995, p999 = data$p999,
p9999 = data$p9999, type="quadratic" )
data <- subset(wtid_clean, select=c(country, year, p99, p995, p999, p9999), year %in% c(1913:2012) & country %in% c("United States", "France"))
mapply(match_ratios_wrapper, p99 = data$p99, p995 = data$p995, p999 = data$p999,
p9999 = data$p9999, type="quadratic" )
match_ratios_sequentiel <- function(data,
type = c("quadratic", "absolute", "relative")){
type <- match.arg(type, several.ok = TRUE)
for(t in type){
data[, paste0(t, "Approximation")] <- mapply(match_ratios_wrapper,
p99 = data$p99,
p995 = data$p995,
p999 = data$p999,
p9999 = data$p9999,
type = t)
}
data
}
match_ratios_sequentiel(data)
match_ratios_sequentiel <- function(data,
type = c("quadratic", "absolute", "relative")){
type <- match.arg(type, several.ok = TRUE)
for(t in type){
data[, paste0(t, "ShapeApprox")] <- mapply(match_ratios_wrapper,
p99 = data$p99,
p995 = data$p995,
p999 = data$p999,
p9999 = data$p9999,
type = t)
}
data
}
match_ratios_parallel <- function(data, cores = 3
type = c("quadratic", "absolute", "relative")){
library(parallel)
type <- match.arg(type, several.ok = TRUE)
if(is.null(cores)){
cores <- detectCores() - 1
}
## parallel apply-function is platform-dependent:
if(.Platform$OS.type != "windows") {
# simply use forking for unix, mac:
pmapply <- function(FUN, ...) {
mcmapply(FUN = FUN, ..., mc.cores = cores)
}
} else {
# use socket clusters on windows
if(is.null(cluster)) {
cluster <- makePSOCKcluster(rep("localhost", detectCores()-1))
on.exit(stopCluster(cl = cluster))
}
# make sure RNG is set to parallel mode:
RNGkind("L'Ecuyer-CMRG")
clusterSetRNGStream(cluster)
pmapply <- function(FUN, ...) {
clusterMap(cl = cluster, fun = FUN, ...)
}
}
for(t in type){
data[, paste0(t, "ShapeApprox")] <- pmapply(FUN = match_ratios_wrapper,
p99 = data$p99,
p995 = data$p995,
p999 = data$p999,
p9999 = data$p9999,
type = t)
}
data
}
match_ratios_parallel <- function(data, cores = 3
type = c("quadratic", "absolute", "relative")){
match_ratios_parallel <- function(data, cores = 3,
type = c("quadratic", "absolute", "relative")){
library(parallel)
type <- match.arg(type, several.ok = TRUE)
if(is.null(cores)){
cores <- detectCores() - 1
}
## parallel apply-function is platform-dependent:
if(.Platform$OS.type != "windows") {
# simply use forking for unix, mac:
pmapply <- function(FUN, ...) {
mcmapply(FUN = FUN, ..., mc.cores = cores)
}
} else {
# use socket clusters on windows
if(is.null(cluster)) {
cluster <- makePSOCKcluster(rep("localhost", detectCores()-1))
on.exit(stopCluster(cl = cluster))
}
# make sure RNG is set to parallel mode:
RNGkind("L'Ecuyer-CMRG")
clusterSetRNGStream(cluster)
pmapply <- function(FUN, ...) {
clusterMap(cl = cluster, fun = FUN, ...)
}
}
for(t in type){
data[, paste0(t, "ShapeApprox")] <- pmapply(FUN = match_ratios_wrapper,
p99 = data$p99,
p995 = data$p995,
p999 = data$p999,
p9999 = data$p9999,
type = t)
}
data
}
match_ratios_parallel(data)
match_ratios_parallel <- function(data, cores = 3,
type = c("quadratic", "absolute", "relative")){
library(parallel)
type <- match.arg(type, several.ok = TRUE)
if(is.null(cores)){
cores <- detectCores() - 1
}
## parallel apply-function is platform-dependent:
if(.Platform$OS.type != "windows") {
# simply use forking for unix, mac:
pmapply <- function(FUN, ...) {
mcmapply(FUN = FUN, ..., mc.cores = cores)
}
} else {
# use socket clusters on windows
if(is.null(cluster)) {
cluster <- makePSOCKcluster(rep("localhost", detectCores()-1))
on.exit(stopCluster(cl = cluster))
}
# make sure RNG is set to parallel mode:
RNGkind("L'Ecuyer-CMRG")
clusterSetRNGStream(cluster)
pmapply <- function(FUN, ...) {
clusterMap(cl = cluster, fun = FUN, ...)
}
}
match_ratios_sequentiel <- function(data,
type = c("quadratic", "absolute", "relative")){
type <- match.arg(type, several.ok = TRUE)
processed_data <- subset(data, select=c(country, year))
for(t in type){
processed_data[, paste0(t, "ShapeApprox")] <- mapply(match_ratios_wrapper,
p99 = data$p99,
p995 = data$p995,
p999 = data$p999,
p9999 = data$p9999,
type = t)
}
processed_data
}
}
match_ratios_parallel(data)
match_ratios_parallel <- function(data, cores = 3,
type = c("quadratic", "absolute", "relative")){
library(parallel)
type <- match.arg(type, several.ok = TRUE)
if(is.null(cores)){
cores <- detectCores() - 1
}
## parallel apply-function is platform-dependent:
if(.Platform$OS.type != "windows") {
# simply use forking for unix, mac:
pmapply <- function(FUN, ...) {
mcmapply(FUN = FUN, ..., mc.cores = cores)
}
} else {
# use socket clusters on windows
if(is.null(cluster)) {
cluster <- makePSOCKcluster(rep("localhost", detectCores()-1))
on.exit(stopCluster(cl = cluster))
}
# make sure RNG is set to parallel mode:
RNGkind("L'Ecuyer-CMRG")
clusterSetRNGStream(cluster)
pmapply <- function(FUN, ...) {
clusterMap(cl = cluster, fun = FUN, ...)
}
}
processed_data <- subset(data, select=c(country, year))
for(t in type){
processed_data[, paste0(t, "ShapeApprox")] <- mapply(match_ratios_wrapper,
p99 = data$p99,
p995 = data$p995,
p999 = data$p999,
p9999 = data$p9999,
type = t)
}
processed_data
}
match_ratios_parallel(data)
data_seqentially_calculated <- match_ratios_sequentiel(data)
data_parallel_calculated <- match_ratios_parallel(data)
identical(data_parallel_calculated, data_seqentially_calculated)
all.equal(data_parallel_calculated, data_seqentially_calculated)
match_ratios_sequentiel <- function(data,
type = c("quadratic", "absolute", "relative")){
type <- match.arg(type, several.ok = TRUE)
processed_data <- subset(data, select=c(country, year))
for(t in type){
processed_data[, paste0(t, "ShapeApprox")] <- mapply(match_ratios_wrapper,
p99 = data$p99,
p995 = data$p995,
p999 = data$p999,
p9999 = data$p9999,
type = t)
}
processed_data
}
data_seqentially_calculated <- match_ratios_sequentiel(data)
data_parallel_calculated <- match_ratios_parallel(data)
all.equal(data_parallel_calculated, data_seqentially_calculated)
identical(data_parallel_calculated, data_seqentially_calculated)
head(data_parallel_calculated)
ggplot(data = data_parallel_calculated) +
geom_line(aes(x = year, y = quadraticShapeAppro, color = country, lty = country)) +
ylab("shape estimate") +
ggtitle("test") +
theme_minimal(base_size=18)
library(ggplot2)
ggplot(data = data_parallel_calculated) +
geom_line(aes(x = year, y = quadraticShapeAppro, color = country, lty = country)) +
ylab("shape estimate") +
ggtitle("test") +
theme_minimal(base_size=18)
ggplot(data = data_parallel_calculated) +
geom_line(aes(x = year, y = quadraticShapeApprox, color = country, lty = country)) +
ylab("shape estimate") +
ggtitle("test") +
theme_minimal(base_size=18)
head(data_parallel_calculated)
ggplot(data = data_parallel_calculated) +
geom_line(aes(x = year, y = absoluteShapeApprox, color = country, lty = country)) +
ylab("shape estimate") +
ggtitle("Shape estimates: absolute") +
theme_minimal(base_size=18)
ggplot(data = data_parallel_calculated) +
geom_line(aes(x = year, y = relativeShapeApprox, color = country, lty = country)) +
ylab("shape estimate") +
ggtitle("Shape estimates: relative") +
theme_minimal(base_size=18)
data_parallel_calculated$quadraticShapeApprox - data_parallel_calculated$absoluteShapeApprox
mean(data_parallel_calculated$quadraticShapeApprox - data_parallel_calculated$absoluteShapeApprox)
mean(data_parallel_calculated$quadraticShapeApprox - data_parallel_calculated$absoluteShapeApprox, na.rm=T)
